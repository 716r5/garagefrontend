{"version":3,"file":"static/js/420.ffb43121.chunk.js","mappings":"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","sources":["../node_modules/@radix-ui/react-context/src/create-context.tsx","../node_modules/@radix-ui/react-compose-refs/src/compose-refs.tsx","../node_modules/@radix-ui/react-slot/src/slot.tsx","../node_modules/@radix-ui/react-collection/src/ordered-dictionary.ts","../node_modules/@radix-ui/primitive/src/primitive.tsx","../node_modules/@radix-ui/react-use-layout-effect/src/use-layout-effect.tsx","../node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state.tsx","../node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state-reducer.tsx","../node_modules/@radix-ui/react-primitive/src/primitive.tsx","../node_modules/@radix-ui/react-presence/src/presence.tsx","../node_modules/@radix-ui/react-presence/src/use-state-machine.tsx","../node_modules/@radix-ui/react-id/src/id.tsx","../node_modules/@radix-ui/react-collapsible/src/collapsible.tsx","../node_modules/@radix-ui/react-direction/src/direction.tsx","../node_modules/@radix-ui/react-accordion/src/accordion.tsx","../node_modules/@radix-ui/react-collection/src/collection-legacy.tsx"],"sourcesContent":["import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  const Provider: React.FC<ContextValueType & { children: React.ReactNode }> = (props) => {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  };\n\n  Provider.displayName = rootComponentName + 'Provider';\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    const Provider: React.FC<\n      ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    > = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    };\n\n    Provider.displayName = rootComponentName + 'Provider';\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n","import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n","import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n","// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n","/* eslint-disable no-restricted-properties */\n\n/* eslint-disable no-restricted-globals */\nexport const canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n/* eslint-enable no-restricted-globals */\n\nexport function composeEventHandlers<E extends { defaultPrevented: boolean }>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport function getOwnerWindow(element: Node | null | undefined) {\n  if (!canUseDOM) {\n    throw new Error('Cannot access window outside of the DOM');\n  }\n  // eslint-disable-next-line no-restricted-globals\n  return element?.ownerDocument?.defaultView ?? window;\n}\n\nexport function getOwnerDocument(element: Node | null | undefined) {\n  if (!canUseDOM) {\n    throw new Error('Cannot access document outside of the DOM');\n  }\n  // eslint-disable-next-line no-restricted-globals\n  return element?.ownerDocument ?? document;\n}\n\n/**\n * Lifted from https://github.com/ariakit/ariakit/blob/main/packages/ariakit-core/src/utils/dom.ts#L37\n * MIT License, Copyright (c) AriaKit.\n */\nexport function getActiveElement(\n  node: Node | null | undefined,\n  activeDescendant = false\n): HTMLElement | null {\n  const { activeElement } = getOwnerDocument(node);\n  if (!activeElement?.nodeName) {\n    // `activeElement` might be an empty object if we're interacting with elements\n    // inside of an iframe.\n    return null;\n  }\n\n  if (isFrame(activeElement) && activeElement.contentDocument) {\n    return getActiveElement(activeElement.contentDocument.body, activeDescendant);\n  }\n\n  if (activeDescendant) {\n    const id = activeElement.getAttribute('aria-activedescendant');\n    if (id) {\n      const element = getOwnerDocument(activeElement).getElementById(id);\n      if (element) {\n        return element;\n      }\n    }\n  }\n\n  return activeElement as HTMLElement | null;\n}\n\nexport function isFrame(element: Element): element is HTMLIFrameElement {\n  return element.tagName === 'IFRAME';\n}\n","import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = globalThis?.document ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n","import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// Prevent bundlers from trying to optimize the import\nconst useInsertionEffect: typeof useLayoutEffect =\n  (React as any)[' useInsertionEffect '.trim().toString()] || useLayoutEffect;\n\ntype ChangeHandler<T> = (state: T) => void;\ntype SetStateFn<T> = React.Dispatch<React.SetStateAction<T>>;\n\ninterface UseControllableStateParams<T> {\n  prop?: T | undefined;\n  defaultProp: T;\n  onChange?: ChangeHandler<T>;\n  caller?: string;\n}\n\nexport function useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n  caller,\n}: UseControllableStateParams<T>): [T, SetStateFn<T>] {\n  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({\n    defaultProp,\n    onChange,\n  });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(prop !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  const setValue = React.useCallback<SetStateFn<T>>(\n    (nextValue) => {\n      if (isControlled) {\n        const value = isFunction(nextValue) ? nextValue(prop) : nextValue;\n        if (value !== prop) {\n          onChangeRef.current?.(value);\n        }\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, onChangeRef]\n  );\n\n  return [value, setValue];\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>): [\n  Value: T,\n  setValue: React.Dispatch<React.SetStateAction<T>>,\n  OnChangeRef: React.RefObject<ChangeHandler<T> | undefined>,\n] {\n  const [value, setValue] = React.useState(defaultProp);\n  const prevValueRef = React.useRef(value);\n\n  const onChangeRef = React.useRef(onChange);\n  useInsertionEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      onChangeRef.current?.(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef]);\n\n  return [value, setValue, onChangeRef];\n}\n\nfunction isFunction(value: unknown): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","import * as React from 'react';\nimport { useEffectEvent } from '@radix-ui/react-use-effect-event';\n\ntype ChangeHandler<T> = (state: T) => void;\n\ninterface UseControllableStateParams<T> {\n  prop: T | undefined;\n  defaultProp: T;\n  onChange: ChangeHandler<T> | undefined;\n  caller: string;\n}\n\ninterface AnyAction {\n  type: string;\n}\n\nconst SYNC_STATE = Symbol('RADIX:SYNC_STATE');\n\ninterface SyncStateAction<T> {\n  type: typeof SYNC_STATE;\n  state: T;\n}\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialState: S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, I, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: I,\n  init: (i: I & { state: T }) => S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: any,\n  init?: (i: any) => Omit<S, 'state'>\n): [S & { state: T }, React.Dispatch<A>] {\n  const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;\n  const isControlled = controlledState !== undefined;\n\n  const onChange = useEffectEvent(onChangeProp);\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(controlledState !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  type InternalState = S & { state: T };\n  const args: [InternalState] = [{ ...initialArg, state: defaultProp }];\n  if (init) {\n    // @ts-expect-error\n    args.push(init);\n  }\n\n  const [internalState, dispatch] = React.useReducer(\n    (state: InternalState, action: A | SyncStateAction<T>): InternalState => {\n      if (action.type === SYNC_STATE) {\n        return { ...state, state: action.state };\n      }\n\n      const next = reducer(state, action);\n      if (isControlled && !Object.is(next.state, state.state)) {\n        onChange(next.state);\n      }\n      return next;\n    },\n    ...args\n  );\n\n  const uncontrolledState = internalState.state;\n  const prevValueRef = React.useRef(uncontrolledState);\n  React.useEffect(() => {\n    if (prevValueRef.current !== uncontrolledState) {\n      prevValueRef.current = uncontrolledState;\n      if (!isControlled) {\n        onChange(uncontrolledState);\n      }\n    }\n  }, [onChange, uncontrolledState, prevValueRef, isControlled]);\n\n  const state = React.useMemo(() => {\n    const isControlled = controlledState !== undefined;\n    if (isControlled) {\n      return { ...internalState, state: controlledState };\n    }\n\n    return internalState;\n  }, [internalState, controlledState]);\n\n  React.useEffect(() => {\n    // Sync internal state for controlled components so that reducer is called\n    // with the correct state values\n    if (isControlled && !Object.is(controlledState, internalState.state)) {\n      dispatch({ type: SYNC_STATE, state: controlledState });\n    }\n  }, [controlledState, internalState.state, isControlled]);\n\n  return [state, dispatch as React.Dispatch<A>];\n}\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { createSlot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'form',\n  'h2',\n  'h3',\n  'img',\n  'input',\n  'label',\n  'li',\n  'nav',\n  'ol',\n  'p',\n  'select',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\ntype Primitives = { [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce((primitive, node) => {\n  const Slot = createSlot(`Primitive.${node}`);\n  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp: any = asChild ? Slot : node;\n\n    if (typeof window !== 'undefined') {\n      (window as any)[Symbol.for('radix-ui')] = true;\n    }\n\n    return <Comp {...primitiveProps} ref={forwardedRef} />;\n  });\n\n  Node.displayName = `Primitive.${node}`;\n\n  return { ...primitive, [node]: Node };\n}, {} as Primitives);\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not necessary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click \n * target.dispatchEvent(new Event(click))\n *\n * dispatching a custom type within a non-discrete event \n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(customType))}\n *\n * dispatching a custom type within a `discrete` event \n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(customType))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */\n\nfunction dispatchDiscreteCustomEvent<E extends CustomEvent>(target: E['target'], event: E) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n};\nexport type { PrimitivePropsWithRef };\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './use-state-machine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement<{ ref?: React.Ref<HTMLElement> }>;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration | null>(null);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        // The event.animationName is unescaped for CSS syntax,\n        // so we need to escape it to compare with the animationName computed from the style.\n        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      stylesRef.current = node ? getComputedStyle(node) : null;\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles: CSSStyleDeclaration | null) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement<{ ref?: React.Ref<unknown> }>) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nconst Root = Presence;\n\nexport {\n  Presence,\n  //\n  Root,\n};\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n//  https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n","import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// We spaces with `.trim().toString()` to prevent bundlers from trying to `import { useId } from 'react';`\nconst useReactId = (React as any)[' useId '.trim().toString()] || (() => undefined);\nlet count = 0;\n\nfunction useId(deterministicId?: string): string {\n  const [id, setId] = React.useState<string | undefined>(useReactId());\n  // React versions older than 18 will have client-side ids only.\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : '');\n}\n\nexport { useId };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { Presence } from '@radix-ui/react-presence';\nimport { useId } from '@radix-ui/react-id';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Collapsible\n * -----------------------------------------------------------------------------------------------*/\n\nconst COLLAPSIBLE_NAME = 'Collapsible';\n\ntype ScopedProps<P> = P & { __scopeCollapsible?: Scope };\nconst [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);\n\ntype CollapsibleContextValue = {\n  contentId: string;\n  disabled?: boolean;\n  open: boolean;\n  onOpenToggle(): void;\n};\n\nconst [CollapsibleProvider, useCollapsibleContext] =\n  createCollapsibleContext<CollapsibleContextValue>(COLLAPSIBLE_NAME);\n\ntype CollapsibleElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface CollapsibleProps extends PrimitiveDivProps {\n  defaultOpen?: boolean;\n  open?: boolean;\n  disabled?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst Collapsible = React.forwardRef<CollapsibleElement, CollapsibleProps>(\n  (props: ScopedProps<CollapsibleProps>, forwardedRef) => {\n    const {\n      __scopeCollapsible,\n      open: openProp,\n      defaultOpen,\n      disabled,\n      onOpenChange,\n      ...collapsibleProps\n    } = props;\n\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen ?? false,\n      onChange: onOpenChange,\n      caller: COLLAPSIBLE_NAME,\n    });\n\n    return (\n      <CollapsibleProvider\n        scope={__scopeCollapsible}\n        disabled={disabled}\n        contentId={useId()}\n        open={open}\n        onOpenToggle={React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen])}\n      >\n        <Primitive.div\n          data-state={getState(open)}\n          data-disabled={disabled ? '' : undefined}\n          {...collapsibleProps}\n          ref={forwardedRef}\n        />\n      </CollapsibleProvider>\n    );\n  }\n);\n\nCollapsible.displayName = COLLAPSIBLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * CollapsibleTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'CollapsibleTrigger';\n\ntype CollapsibleTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface CollapsibleTriggerProps extends PrimitiveButtonProps {}\n\nconst CollapsibleTrigger = React.forwardRef<CollapsibleTriggerElement, CollapsibleTriggerProps>(\n  (props: ScopedProps<CollapsibleTriggerProps>, forwardedRef) => {\n    const { __scopeCollapsible, ...triggerProps } = props;\n    const context = useCollapsibleContext(TRIGGER_NAME, __scopeCollapsible);\n    return (\n      <Primitive.button\n        type=\"button\"\n        aria-controls={context.contentId}\n        aria-expanded={context.open || false}\n        data-state={getState(context.open)}\n        data-disabled={context.disabled ? '' : undefined}\n        disabled={context.disabled}\n        {...triggerProps}\n        ref={forwardedRef}\n        onClick={composeEventHandlers(props.onClick, context.onOpenToggle)}\n      />\n    );\n  }\n);\n\nCollapsibleTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * CollapsibleContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'CollapsibleContent';\n\ntype CollapsibleContentElement = CollapsibleContentImplElement;\ninterface CollapsibleContentProps extends Omit<CollapsibleContentImplProps, 'present'> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst CollapsibleContent = React.forwardRef<CollapsibleContentElement, CollapsibleContentProps>(\n  (props: ScopedProps<CollapsibleContentProps>, forwardedRef) => {\n    const { forceMount, ...contentProps } = props;\n    const context = useCollapsibleContext(CONTENT_NAME, props.__scopeCollapsible);\n    return (\n      <Presence present={forceMount || context.open}>\n        {({ present }) => (\n          <CollapsibleContentImpl {...contentProps} ref={forwardedRef} present={present} />\n        )}\n      </Presence>\n    );\n  }\n);\n\nCollapsibleContent.displayName = CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype CollapsibleContentImplElement = React.ComponentRef<typeof Primitive.div>;\ninterface CollapsibleContentImplProps extends PrimitiveDivProps {\n  present: boolean;\n}\n\nconst CollapsibleContentImpl = React.forwardRef<\n  CollapsibleContentImplElement,\n  CollapsibleContentImplProps\n>((props: ScopedProps<CollapsibleContentImplProps>, forwardedRef) => {\n  const { __scopeCollapsible, present, children, ...contentProps } = props;\n  const context = useCollapsibleContext(CONTENT_NAME, __scopeCollapsible);\n  const [isPresent, setIsPresent] = React.useState(present);\n  const ref = React.useRef<CollapsibleContentImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const heightRef = React.useRef<number | undefined>(0);\n  const height = heightRef.current;\n  const widthRef = React.useRef<number | undefined>(0);\n  const width = widthRef.current;\n  // when opening we want it to immediately open to retrieve dimensions\n  // when closing we delay `present` to retrieve dimensions before closing\n  const isOpen = context.open || isPresent;\n  const isMountAnimationPreventedRef = React.useRef(isOpen);\n  const originalStylesRef = React.useRef<Record<string, string>>(undefined);\n\n  React.useEffect(() => {\n    const rAF = requestAnimationFrame(() => (isMountAnimationPreventedRef.current = false));\n    return () => cancelAnimationFrame(rAF);\n  }, []);\n\n  useLayoutEffect(() => {\n    const node = ref.current;\n    if (node) {\n      originalStylesRef.current = originalStylesRef.current || {\n        transitionDuration: node.style.transitionDuration,\n        animationName: node.style.animationName,\n      };\n      // block any animations/transitions so the element renders at its full dimensions\n      node.style.transitionDuration = '0s';\n      node.style.animationName = 'none';\n\n      // get width and height from full dimensions\n      const rect = node.getBoundingClientRect();\n      heightRef.current = rect.height;\n      widthRef.current = rect.width;\n\n      // kick off any animations/transitions that were originally set up if it isn't the initial mount\n      if (!isMountAnimationPreventedRef.current) {\n        node.style.transitionDuration = originalStylesRef.current.transitionDuration!;\n        node.style.animationName = originalStylesRef.current.animationName!;\n      }\n\n      setIsPresent(present);\n    }\n    /**\n     * depends on `context.open` because it will change to `false`\n     * when a close is triggered but `present` will be `false` on\n     * animation end (so when close finishes). This allows us to\n     * retrieve the dimensions *before* closing.\n     */\n  }, [context.open, present]);\n\n  return (\n    <Primitive.div\n      data-state={getState(context.open)}\n      data-disabled={context.disabled ? '' : undefined}\n      id={context.contentId}\n      hidden={!isOpen}\n      {...contentProps}\n      ref={composedRefs}\n      style={{\n        [`--radix-collapsible-content-height` as any]: height ? `${height}px` : undefined,\n        [`--radix-collapsible-content-width` as any]: width ? `${width}px` : undefined,\n        ...props.style,\n      }}\n    >\n      {isOpen && children}\n    </Primitive.div>\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getState(open?: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nconst Root = Collapsible;\nconst Trigger = CollapsibleTrigger;\nconst Content = CollapsibleContent;\n\nexport {\n  createCollapsibleScope,\n  //\n  Collapsible,\n  CollapsibleTrigger,\n  CollapsibleContent,\n  //\n  Root,\n  Trigger,\n  Content,\n};\nexport type { CollapsibleProps, CollapsibleTriggerProps, CollapsibleContentProps };\n","import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as CollapsiblePrimitive from '@radix-ui/react-collapsible';\nimport { createCollapsibleScope } from '@radix-ui/react-collapsible';\nimport { useId } from '@radix-ui/react-id';\n\nimport type { Scope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\n\ntype Direction = 'ltr' | 'rtl';\n\n/* -------------------------------------------------------------------------------------------------\n * Accordion\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACCORDION_NAME = 'Accordion';\nconst ACCORDION_KEYS = ['Home', 'End', 'ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'];\n\nconst [Collection, useCollection, createCollectionScope] =\n  createCollection<AccordionTriggerElement>(ACCORDION_NAME);\n\ntype ScopedProps<P> = P & { __scopeAccordion?: Scope };\nconst [createAccordionContext, createAccordionScope] = createContextScope(ACCORDION_NAME, [\n  createCollectionScope,\n  createCollapsibleScope,\n]);\nconst useCollapsibleScope = createCollapsibleScope();\n\ntype AccordionElement = AccordionImplMultipleElement | AccordionImplSingleElement;\ninterface AccordionSingleProps extends AccordionImplSingleProps {\n  type: 'single';\n}\ninterface AccordionMultipleProps extends AccordionImplMultipleProps {\n  type: 'multiple';\n}\n\nconst Accordion = React.forwardRef<AccordionElement, AccordionSingleProps | AccordionMultipleProps>(\n  (props: ScopedProps<AccordionSingleProps | AccordionMultipleProps>, forwardedRef) => {\n    const { type, ...accordionProps } = props;\n    const singleProps = accordionProps as AccordionImplSingleProps;\n    const multipleProps = accordionProps as AccordionImplMultipleProps;\n    return (\n      <Collection.Provider scope={props.__scopeAccordion}>\n        {type === 'multiple' ? (\n          <AccordionImplMultiple {...multipleProps} ref={forwardedRef} />\n        ) : (\n          <AccordionImplSingle {...singleProps} ref={forwardedRef} />\n        )}\n      </Collection.Provider>\n    );\n  }\n);\n\nAccordion.displayName = ACCORDION_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype AccordionValueContextValue = {\n  value: string[];\n  onItemOpen(value: string): void;\n  onItemClose(value: string): void;\n};\n\nconst [AccordionValueProvider, useAccordionValueContext] =\n  createAccordionContext<AccordionValueContextValue>(ACCORDION_NAME);\n\nconst [AccordionCollapsibleProvider, useAccordionCollapsibleContext] = createAccordionContext(\n  ACCORDION_NAME,\n  { collapsible: false }\n);\n\ntype AccordionImplSingleElement = AccordionImplElement;\ninterface AccordionImplSingleProps extends AccordionImplProps {\n  /**\n   * The controlled stateful value of the accordion item whose content is expanded.\n   */\n  value?: string;\n  /**\n   * The value of the item whose content is expanded when the accordion is initially rendered. Use\n   * `defaultValue` if you do not need to control the state of an accordion.\n   */\n  defaultValue?: string;\n  /**\n   * The callback that fires when the state of the accordion changes.\n   */\n  onValueChange?(value: string): void;\n  /**\n   * Whether an accordion item can be collapsed after it has been opened.\n   * @default false\n   */\n  collapsible?: boolean;\n}\n\nconst AccordionImplSingle = React.forwardRef<AccordionImplSingleElement, AccordionImplSingleProps>(\n  (props: ScopedProps<AccordionImplSingleProps>, forwardedRef) => {\n    const {\n      value: valueProp,\n      defaultValue,\n      onValueChange = () => {},\n      collapsible = false,\n      ...accordionSingleProps\n    } = props;\n\n    const [value, setValue] = useControllableState({\n      prop: valueProp,\n      defaultProp: defaultValue ?? '',\n      onChange: onValueChange,\n      caller: ACCORDION_NAME,\n    });\n\n    return (\n      <AccordionValueProvider\n        scope={props.__scopeAccordion}\n        value={React.useMemo(() => (value ? [value] : []), [value])}\n        onItemOpen={setValue}\n        onItemClose={React.useCallback(() => collapsible && setValue(''), [collapsible, setValue])}\n      >\n        <AccordionCollapsibleProvider scope={props.__scopeAccordion} collapsible={collapsible}>\n          <AccordionImpl {...accordionSingleProps} ref={forwardedRef} />\n        </AccordionCollapsibleProvider>\n      </AccordionValueProvider>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype AccordionImplMultipleElement = AccordionImplElement;\ninterface AccordionImplMultipleProps extends AccordionImplProps {\n  /**\n   * The controlled stateful value of the accordion items whose contents are expanded.\n   */\n  value?: string[];\n  /**\n   * The value of the items whose contents are expanded when the accordion is initially rendered. Use\n   * `defaultValue` if you do not need to control the state of an accordion.\n   */\n  defaultValue?: string[];\n  /**\n   * The callback that fires when the state of the accordion changes.\n   */\n  onValueChange?(value: string[]): void;\n}\n\nconst AccordionImplMultiple = React.forwardRef<\n  AccordionImplMultipleElement,\n  AccordionImplMultipleProps\n>((props: ScopedProps<AccordionImplMultipleProps>, forwardedRef) => {\n  const {\n    value: valueProp,\n    defaultValue,\n    onValueChange = () => {},\n    ...accordionMultipleProps\n  } = props;\n\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue ?? [],\n    onChange: onValueChange,\n    caller: ACCORDION_NAME,\n  });\n\n  const handleItemOpen = React.useCallback(\n    (itemValue: string) => setValue((prevValue = []) => [...prevValue, itemValue]),\n    [setValue]\n  );\n\n  const handleItemClose = React.useCallback(\n    (itemValue: string) =>\n      setValue((prevValue = []) => prevValue.filter((value) => value !== itemValue)),\n    [setValue]\n  );\n\n  return (\n    <AccordionValueProvider\n      scope={props.__scopeAccordion}\n      value={value}\n      onItemOpen={handleItemOpen}\n      onItemClose={handleItemClose}\n    >\n      <AccordionCollapsibleProvider scope={props.__scopeAccordion} collapsible={true}>\n        <AccordionImpl {...accordionMultipleProps} ref={forwardedRef} />\n      </AccordionCollapsibleProvider>\n    </AccordionValueProvider>\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype AccordionImplContextValue = {\n  disabled?: boolean;\n  direction: AccordionImplProps['dir'];\n  orientation: AccordionImplProps['orientation'];\n};\n\nconst [AccordionImplProvider, useAccordionContext] =\n  createAccordionContext<AccordionImplContextValue>(ACCORDION_NAME);\n\ntype AccordionImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface AccordionImplProps extends PrimitiveDivProps {\n  /**\n   * Whether or not an accordion is disabled from user interaction.\n   *\n   * @defaultValue false\n   */\n  disabled?: boolean;\n  /**\n   * The layout in which the Accordion operates.\n   * @default vertical\n   */\n  orientation?: React.AriaAttributes['aria-orientation'];\n  /**\n   * The language read direction.\n   */\n  dir?: Direction;\n}\n\nconst AccordionImpl = React.forwardRef<AccordionImplElement, AccordionImplProps>(\n  (props: ScopedProps<AccordionImplProps>, forwardedRef) => {\n    const { __scopeAccordion, disabled, dir, orientation = 'vertical', ...accordionProps } = props;\n    const accordionRef = React.useRef<AccordionImplElement>(null);\n    const composedRefs = useComposedRefs(accordionRef, forwardedRef);\n    const getItems = useCollection(__scopeAccordion);\n    const direction = useDirection(dir);\n    const isDirectionLTR = direction === 'ltr';\n\n    const handleKeyDown = composeEventHandlers(props.onKeyDown, (event) => {\n      if (!ACCORDION_KEYS.includes(event.key)) return;\n      const target = event.target as HTMLElement;\n      const triggerCollection = getItems().filter((item) => !item.ref.current?.disabled);\n      const triggerIndex = triggerCollection.findIndex((item) => item.ref.current === target);\n      const triggerCount = triggerCollection.length;\n\n      if (triggerIndex === -1) return;\n\n      // Prevents page scroll while user is navigating\n      event.preventDefault();\n\n      let nextIndex = triggerIndex;\n      const homeIndex = 0;\n      const endIndex = triggerCount - 1;\n\n      const moveNext = () => {\n        nextIndex = triggerIndex + 1;\n        if (nextIndex > endIndex) {\n          nextIndex = homeIndex;\n        }\n      };\n\n      const movePrev = () => {\n        nextIndex = triggerIndex - 1;\n        if (nextIndex < homeIndex) {\n          nextIndex = endIndex;\n        }\n      };\n\n      switch (event.key) {\n        case 'Home':\n          nextIndex = homeIndex;\n          break;\n        case 'End':\n          nextIndex = endIndex;\n          break;\n        case 'ArrowRight':\n          if (orientation === 'horizontal') {\n            if (isDirectionLTR) {\n              moveNext();\n            } else {\n              movePrev();\n            }\n          }\n          break;\n        case 'ArrowDown':\n          if (orientation === 'vertical') {\n            moveNext();\n          }\n          break;\n        case 'ArrowLeft':\n          if (orientation === 'horizontal') {\n            if (isDirectionLTR) {\n              movePrev();\n            } else {\n              moveNext();\n            }\n          }\n          break;\n        case 'ArrowUp':\n          if (orientation === 'vertical') {\n            movePrev();\n          }\n          break;\n      }\n\n      const clampedIndex = nextIndex % triggerCount;\n      triggerCollection[clampedIndex]!.ref.current?.focus();\n    });\n\n    return (\n      <AccordionImplProvider\n        scope={__scopeAccordion}\n        disabled={disabled}\n        direction={dir}\n        orientation={orientation}\n      >\n        <Collection.Slot scope={__scopeAccordion}>\n          <Primitive.div\n            {...accordionProps}\n            data-orientation={orientation}\n            ref={composedRefs}\n            onKeyDown={disabled ? undefined : handleKeyDown}\n          />\n        </Collection.Slot>\n      </AccordionImplProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * AccordionItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'AccordionItem';\n\ntype AccordionItemContextValue = { open?: boolean; disabled?: boolean; triggerId: string };\nconst [AccordionItemProvider, useAccordionItemContext] =\n  createAccordionContext<AccordionItemContextValue>(ITEM_NAME);\n\ntype AccordionItemElement = React.ComponentRef<typeof CollapsiblePrimitive.Root>;\ntype CollapsibleProps = React.ComponentPropsWithoutRef<typeof CollapsiblePrimitive.Root>;\ninterface AccordionItemProps\n  extends Omit<CollapsibleProps, 'open' | 'defaultOpen' | 'onOpenChange'> {\n  /**\n   * Whether or not an accordion item is disabled from user interaction.\n   *\n   * @defaultValue false\n   */\n  disabled?: boolean;\n  /**\n   * A string value for the accordion item. All items within an accordion should use a unique value.\n   */\n  value: string;\n}\n\n/**\n * `AccordionItem` contains all of the parts of a collapsible section inside of an `Accordion`.\n */\nconst AccordionItem = React.forwardRef<AccordionItemElement, AccordionItemProps>(\n  (props: ScopedProps<AccordionItemProps>, forwardedRef) => {\n    const { __scopeAccordion, value, ...accordionItemProps } = props;\n    const accordionContext = useAccordionContext(ITEM_NAME, __scopeAccordion);\n    const valueContext = useAccordionValueContext(ITEM_NAME, __scopeAccordion);\n    const collapsibleScope = useCollapsibleScope(__scopeAccordion);\n    const triggerId = useId();\n    const open = (value && valueContext.value.includes(value)) || false;\n    const disabled = accordionContext.disabled || props.disabled;\n\n    return (\n      <AccordionItemProvider\n        scope={__scopeAccordion}\n        open={open}\n        disabled={disabled}\n        triggerId={triggerId}\n      >\n        <CollapsiblePrimitive.Root\n          data-orientation={accordionContext.orientation}\n          data-state={getState(open)}\n          {...collapsibleScope}\n          {...accordionItemProps}\n          ref={forwardedRef}\n          disabled={disabled}\n          open={open}\n          onOpenChange={(open) => {\n            if (open) {\n              valueContext.onItemOpen(value);\n            } else {\n              valueContext.onItemClose(value);\n            }\n          }}\n        />\n      </AccordionItemProvider>\n    );\n  }\n);\n\nAccordionItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * AccordionHeader\n * -----------------------------------------------------------------------------------------------*/\n\nconst HEADER_NAME = 'AccordionHeader';\n\ntype AccordionHeaderElement = React.ComponentRef<typeof Primitive.h3>;\ntype PrimitiveHeading3Props = React.ComponentPropsWithoutRef<typeof Primitive.h3>;\ninterface AccordionHeaderProps extends PrimitiveHeading3Props {}\n\n/**\n * `AccordionHeader` contains the content for the parts of an `AccordionItem` that will be visible\n * whether or not its content is collapsed.\n */\nconst AccordionHeader = React.forwardRef<AccordionHeaderElement, AccordionHeaderProps>(\n  (props: ScopedProps<AccordionHeaderProps>, forwardedRef) => {\n    const { __scopeAccordion, ...headerProps } = props;\n    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);\n    const itemContext = useAccordionItemContext(HEADER_NAME, __scopeAccordion);\n    return (\n      <Primitive.h3\n        data-orientation={accordionContext.orientation}\n        data-state={getState(itemContext.open)}\n        data-disabled={itemContext.disabled ? '' : undefined}\n        {...headerProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nAccordionHeader.displayName = HEADER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * AccordionTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'AccordionTrigger';\n\ntype AccordionTriggerElement = React.ComponentRef<typeof CollapsiblePrimitive.Trigger>;\ntype CollapsibleTriggerProps = React.ComponentPropsWithoutRef<typeof CollapsiblePrimitive.Trigger>;\ninterface AccordionTriggerProps extends CollapsibleTriggerProps {}\n\n/**\n * `AccordionTrigger` is the trigger that toggles the collapsed state of an `AccordionItem`. It\n * should always be nested inside of an `AccordionHeader`.\n */\nconst AccordionTrigger = React.forwardRef<AccordionTriggerElement, AccordionTriggerProps>(\n  (props: ScopedProps<AccordionTriggerProps>, forwardedRef) => {\n    const { __scopeAccordion, ...triggerProps } = props;\n    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);\n    const itemContext = useAccordionItemContext(TRIGGER_NAME, __scopeAccordion);\n    const collapsibleContext = useAccordionCollapsibleContext(TRIGGER_NAME, __scopeAccordion);\n    const collapsibleScope = useCollapsibleScope(__scopeAccordion);\n    return (\n      <Collection.ItemSlot scope={__scopeAccordion}>\n        <CollapsiblePrimitive.Trigger\n          aria-disabled={(itemContext.open && !collapsibleContext.collapsible) || undefined}\n          data-orientation={accordionContext.orientation}\n          id={itemContext.triggerId}\n          {...collapsibleScope}\n          {...triggerProps}\n          ref={forwardedRef}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nAccordionTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * AccordionContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'AccordionContent';\n\ntype AccordionContentElement = React.ComponentRef<typeof CollapsiblePrimitive.Content>;\ntype CollapsibleContentProps = React.ComponentPropsWithoutRef<typeof CollapsiblePrimitive.Content>;\ninterface AccordionContentProps extends CollapsibleContentProps {}\n\n/**\n * `AccordionContent` contains the collapsible content for an `AccordionItem`.\n */\nconst AccordionContent = React.forwardRef<AccordionContentElement, AccordionContentProps>(\n  (props: ScopedProps<AccordionContentProps>, forwardedRef) => {\n    const { __scopeAccordion, ...contentProps } = props;\n    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);\n    const itemContext = useAccordionItemContext(CONTENT_NAME, __scopeAccordion);\n    const collapsibleScope = useCollapsibleScope(__scopeAccordion);\n    return (\n      <CollapsiblePrimitive.Content\n        role=\"region\"\n        aria-labelledby={itemContext.triggerId}\n        data-orientation={accordionContext.orientation}\n        {...collapsibleScope}\n        {...contentProps}\n        ref={forwardedRef}\n        style={{\n          ['--radix-accordion-content-height' as any]: 'var(--radix-collapsible-content-height)',\n          ['--radix-accordion-content-width' as any]: 'var(--radix-collapsible-content-width)',\n          ...props.style,\n        }}\n      />\n    );\n  }\n);\n\nAccordionContent.displayName = CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getState(open?: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nconst Root = Accordion;\nconst Item = AccordionItem;\nconst Header = AccordionHeader;\nconst Trigger = AccordionTrigger;\nconst Content = AccordionContent;\n\nexport {\n  createAccordionScope,\n  //\n  Accordion,\n  AccordionItem,\n  AccordionHeader,\n  AccordionTrigger,\n  AccordionContent,\n  //\n  Root,\n  Item,\n  Header,\n  Trigger,\n  Content,\n};\nexport type {\n  AccordionSingleProps,\n  AccordionMultipleProps,\n  AccordionItemProps,\n  AccordionHeaderProps,\n  AccordionTriggerProps,\n  AccordionContentProps,\n};\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}></CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n"],"names":["createContextScope","scopeName","createContextScopeDeps","arguments","length","undefined","defaultContexts","createScope","scopeContexts","map","defaultContext","React","scope","contexts","rootComponentName","BaseContext","index","Provider","props","children","context","Context","value","Object","values","jsx","displayName","consumerName","Error","composeContextScopes","_len","scopes","Array","_key","baseScope","scopeHooks","createScope2","useScope","overrideScopes","nextScopes","reduce","nextScopes2","_ref","setRef","ref","current","composeRefs","refs","node","hasCleanup","cleanups","cleanup","i","useComposedRefs","_len2","_key2","createSlot","ownerName","SlotClone","createSlotClone","Slot2","forwardedRef","slotProps","childrenArray","toArray","slottable","find","isSlottable","newElement","newChildren","child","count","only","childrenRef","element","getter","getOwnPropertyDescriptor","get","mayWarn","isReactWarning","getElementRef","props2","childProps","overrideProps","propName","slotPropValue","childPropValue","test","result","filter","Boolean","join","mergeProps","type","SLOTTABLE_IDENTIFIER","Symbol","__radixId","__instanciated","WeakMap","Map","at","array","prototype","call","actualIndex","relativeIndex","toSafeInteger","toSafeIndex","number","Math","trunc","window","document","createElement","composeEventHandlers","originalEventHandler","ourEventHandler","checkForDefaultPrevented","event","defaultPrevented","useLayoutEffect2","globalThis","useInsertionEffect","trim","toString","useLayoutEffect","useControllableState","prop","defaultProp","onChange","caller","uncontrolledProp","setUncontrolledProp","onChangeRef","_ref2","setValue","prevValueRef","useUncontrolledState","isControlled","isControlledRef","wasControlled","from","to","console","warn","nextValue","value2","isFunction","Primitive","primitive","Slot","Node","asChild","primitiveProps","Comp","for","Presence","present","presence","setNode","React2","stylesRef","prevPresentRef","prevAnimationNameRef","initialState","state","send","machine","useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","currentAnimationName","getAnimationName","styles","wasPresent","prevAnimationName","display","timeoutId","ownerWindow","ownerDocument","defaultView","handleAnimationEnd","isCurrentAnimation","includes","CSS","escape","animationName","target","currentFillMode","style","animationFillMode","setTimeout","handleAnimationStart","addEventListener","clearTimeout","removeEventListener","isPresent","node2","getComputedStyle","usePresence","useReactId","useId","deterministicId","id","setId","reactId","String","COLLAPSIBLE_NAME","createCollapsibleContext","createCollapsibleScope","CollapsibleProvider","useCollapsibleContext","Collapsible","__scopeCollapsible","open","openProp","defaultOpen","disabled","onOpenChange","collapsibleProps","setOpen","contentId","onOpenToggle","prevOpen","div","getState","TRIGGER_NAME","CollapsibleTrigger","triggerProps","button","onClick","CONTENT_NAME","CollapsibleContent","forceMount","contentProps","CollapsibleContentImpl","setIsPresent","composedRefs","heightRef","height","widthRef","width","isOpen","isMountAnimationPreventedRef","originalStylesRef","rAF","requestAnimationFrame","cancelAnimationFrame","transitionDuration","rect","getBoundingClientRect","hidden","Root","Trigger","Content","DirectionContext","ACCORDION_NAME","ACCORDION_KEYS","Collection","useCollection","createCollectionScope","name","PROVIDER_NAME","createCollectionContext","CollectionProviderImpl","useCollectionContext","collectionRef","itemMap","CollectionProvider","COLLECTION_SLOT_NAME","CollectionSlotImpl","CollectionSlot","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlotImpl","CollectionItemSlot","itemData","set","delete","ItemSlot","collectionNode","orderedNodes","querySelectorAll","sort","a","b","indexOf","createCollection","createAccordionContext","createAccordionScope","useCollapsibleScope","Accordion","accordionProps","singleProps","multipleProps","__scopeAccordion","AccordionImplMultiple","AccordionImplSingle","AccordionValueProvider","useAccordionValueContext","AccordionCollapsibleProvider","useAccordionCollapsibleContext","collapsible","valueProp","defaultValue","onValueChange","accordionSingleProps","onItemOpen","onItemClose","AccordionImpl","accordionMultipleProps","handleItemOpen","itemValue","handleItemClose","AccordionImplProvider","useAccordionContext","dir","orientation","getItems","isDirectionLTR","localDir","globalDir","useDirection","handleKeyDown","onKeyDown","key","triggerCollection","item","triggerIndex","findIndex","triggerCount","preventDefault","nextIndex","endIndex","moveNext","movePrev","clampedIndex","focus","direction","ITEM_NAME","AccordionItemProvider","useAccordionItemContext","AccordionItem","accordionItemProps","accordionContext","valueContext","collapsibleScope","triggerId","CollapsiblePrimitive","open2","HEADER_NAME","AccordionHeader","headerProps","itemContext","h3","AccordionTrigger","collapsibleContext","AccordionContent","role","Root2","Item","Header","Trigger2","Content2"],"sourceRoot":""}